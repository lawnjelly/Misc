# General Optimization
## Introduction
In an ideal world, computers would run at infinite speed, and the only limit to what we could achieve would be our imagination. In the real world, however, it is all too easy to produce software that will bring even the fastest computer to its knees.

Designing games and other software is thus a compromise between what we would like to be possible, and what we can realistically achieve while maintaining good performance.

To achieve the best results, we have two approaches:
* Work faster
* Work smarter

And preferably, we will use a blend of the two.

### Smoke and Mirrors

Part of working smarter is recognising that, especially in games, we can often get the player to believe they are in a world that is far more complex / interactive / graphically exciting than it really is (under the hood). A good programmer is somewhat akin to a magician, and should strive to learn the tricks of the trade, and try to invent new ones.


## Principles



#### Knuth
#### Low hanging fruit
#### The process
#### Algorithms
#### Data structures
#### Routines



#### Continuous and spikes
#### CPU / GPU / OS

## Profiling
#### Within Godot
#### External tools

## Bottlenecks
#### Bottleneck math
#### Examples


## CPU
#### Threads
#### GDNative / c++

## GPU
#### Drawcalls / API
#### Vertex processing
#### Pixels / Fillrate
#### Platform Specific
#### Mobile / Tile renderers
Battery use

### Links
* 3D Optimization
* 2D Batching

